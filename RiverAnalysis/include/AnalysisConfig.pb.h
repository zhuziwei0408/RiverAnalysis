// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AnalysisConfig.proto

#ifndef PROTOBUF_INCLUDED_AnalysisConfig_2eproto
#define PROTOBUF_INCLUDED_AnalysisConfig_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_AnalysisConfig_2eproto 

namespace protobuf_AnalysisConfig_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_AnalysisConfig_2eproto
class AlgorithmConfig;
class AlgorithmConfigDefaultTypeInternal;
extern AlgorithmConfigDefaultTypeInternal _AlgorithmConfig_default_instance_;
class AnalysisAlarm;
class AnalysisAlarmDefaultTypeInternal;
extern AnalysisAlarmDefaultTypeInternal _AnalysisAlarm_default_instance_;
class AnalysisConfig;
class AnalysisConfigDefaultTypeInternal;
extern AnalysisConfigDefaultTypeInternal _AnalysisConfig_default_instance_;
class AnalysisRect;
class AnalysisRectDefaultTypeInternal;
extern AnalysisRectDefaultTypeInternal _AnalysisRect_default_instance_;
class ConfigList;
class ConfigListDefaultTypeInternal;
extern ConfigListDefaultTypeInternal _ConfigList_default_instance_;
namespace google {
namespace protobuf {
template<> ::AlgorithmConfig* Arena::CreateMaybeMessage<::AlgorithmConfig>(Arena*);
template<> ::AnalysisAlarm* Arena::CreateMaybeMessage<::AnalysisAlarm>(Arena*);
template<> ::AnalysisConfig* Arena::CreateMaybeMessage<::AnalysisConfig>(Arena*);
template<> ::AnalysisRect* Arena::CreateMaybeMessage<::AnalysisRect>(Arena*);
template<> ::ConfigList* Arena::CreateMaybeMessage<::ConfigList>(Arena*);
}  // namespace protobuf
}  // namespace google

enum AlgorithmType {
  SEGMANTIC = 0,
  FLOATER = 1,
  WATERGAUGE = 2,
  LITTER = 3,
  SAND = 4,
  FISHING = 5,
  SWIMING = 6,
  DAM = 7,
  WATERCOLOR = 8,
  INVADE = 9
};
bool AlgorithmType_IsValid(int value);
const AlgorithmType AlgorithmType_MIN = SEGMANTIC;
const AlgorithmType AlgorithmType_MAX = INVADE;
const int AlgorithmType_ARRAYSIZE = AlgorithmType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AlgorithmType_descriptor();
inline const ::std::string& AlgorithmType_Name(AlgorithmType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AlgorithmType_descriptor(), value);
}
inline bool AlgorithmType_Parse(
    const ::std::string& name, AlgorithmType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AlgorithmType>(
    AlgorithmType_descriptor(), name, value);
}
// ===================================================================

class ConfigList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ConfigList) */ {
 public:
  ConfigList();
  virtual ~ConfigList();

  ConfigList(const ConfigList& from);

  inline ConfigList& operator=(const ConfigList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConfigList(ConfigList&& from) noexcept
    : ConfigList() {
    *this = ::std::move(from);
  }

  inline ConfigList& operator=(ConfigList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConfigList* internal_default_instance() {
    return reinterpret_cast<const ConfigList*>(
               &_ConfigList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ConfigList* other);
  friend void swap(ConfigList& a, ConfigList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConfigList* New() const final {
    return CreateMaybeMessage<ConfigList>(NULL);
  }

  ConfigList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConfigList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConfigList& from);
  void MergeFrom(const ConfigList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string configs = 2;
  int configs_size() const;
  void clear_configs();
  static const int kConfigsFieldNumber = 2;
  const ::std::string& configs(int index) const;
  ::std::string* mutable_configs(int index);
  void set_configs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_configs(int index, ::std::string&& value);
  #endif
  void set_configs(int index, const char* value);
  void set_configs(int index, const char* value, size_t size);
  ::std::string* add_configs();
  void add_configs(const ::std::string& value);
  #if LANG_CXX11
  void add_configs(::std::string&& value);
  #endif
  void add_configs(const char* value);
  void add_configs(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& configs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_configs();

  // required string model_path = 1;
  bool has_model_path() const;
  void clear_model_path();
  static const int kModelPathFieldNumber = 1;
  const ::std::string& model_path() const;
  void set_model_path(const ::std::string& value);
  #if LANG_CXX11
  void set_model_path(::std::string&& value);
  #endif
  void set_model_path(const char* value);
  void set_model_path(const char* value, size_t size);
  ::std::string* mutable_model_path();
  ::std::string* release_model_path();
  void set_allocated_model_path(::std::string* model_path);

  // @@protoc_insertion_point(class_scope:ConfigList)
 private:
  void set_has_model_path();
  void clear_has_model_path();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> configs_;
  ::google::protobuf::internal::ArenaStringPtr model_path_;
  friend struct ::protobuf_AnalysisConfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AnalysisRect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AnalysisRect) */ {
 public:
  AnalysisRect();
  virtual ~AnalysisRect();

  AnalysisRect(const AnalysisRect& from);

  inline AnalysisRect& operator=(const AnalysisRect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalysisRect(AnalysisRect&& from) noexcept
    : AnalysisRect() {
    *this = ::std::move(from);
  }

  inline AnalysisRect& operator=(AnalysisRect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalysisRect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalysisRect* internal_default_instance() {
    return reinterpret_cast<const AnalysisRect*>(
               &_AnalysisRect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AnalysisRect* other);
  friend void swap(AnalysisRect& a, AnalysisRect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalysisRect* New() const final {
    return CreateMaybeMessage<AnalysisRect>(NULL);
  }

  AnalysisRect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnalysisRect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnalysisRect& from);
  void MergeFrom(const AnalysisRect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalysisRect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::uint32 x() const;
  void set_x(::google::protobuf::uint32 value);

  // required uint32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::uint32 y() const;
  void set_y(::google::protobuf::uint32 value);

  // required uint32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AnalysisRect)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  friend struct ::protobuf_AnalysisConfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AlgorithmConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AlgorithmConfig) */ {
 public:
  AlgorithmConfig();
  virtual ~AlgorithmConfig();

  AlgorithmConfig(const AlgorithmConfig& from);

  inline AlgorithmConfig& operator=(const AlgorithmConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AlgorithmConfig(AlgorithmConfig&& from) noexcept
    : AlgorithmConfig() {
    *this = ::std::move(from);
  }

  inline AlgorithmConfig& operator=(AlgorithmConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlgorithmConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AlgorithmConfig* internal_default_instance() {
    return reinterpret_cast<const AlgorithmConfig*>(
               &_AlgorithmConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AlgorithmConfig* other);
  friend void swap(AlgorithmConfig& a, AlgorithmConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AlgorithmConfig* New() const final {
    return CreateMaybeMessage<AlgorithmConfig>(NULL);
  }

  AlgorithmConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AlgorithmConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AlgorithmConfig& from);
  void MergeFrom(const AlgorithmConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlgorithmConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AnalysisRect roi_rects = 5;
  int roi_rects_size() const;
  void clear_roi_rects();
  static const int kRoiRectsFieldNumber = 5;
  ::AnalysisRect* mutable_roi_rects(int index);
  ::google::protobuf::RepeatedPtrField< ::AnalysisRect >*
      mutable_roi_rects();
  const ::AnalysisRect& roi_rects(int index) const;
  ::AnalysisRect* add_roi_rects();
  const ::google::protobuf::RepeatedPtrField< ::AnalysisRect >&
      roi_rects() const;

  // required .AlgorithmType algorithm_type = 1;
  bool has_algorithm_type() const;
  void clear_algorithm_type();
  static const int kAlgorithmTypeFieldNumber = 1;
  ::AlgorithmType algorithm_type() const;
  void set_algorithm_type(::AlgorithmType value);

  // required uint32 detect_interval = 2;
  bool has_detect_interval() const;
  void clear_detect_interval();
  static const int kDetectIntervalFieldNumber = 2;
  ::google::protobuf::uint32 detect_interval() const;
  void set_detect_interval(::google::protobuf::uint32 value);

  // optional float water_gauge_length = 3;
  bool has_water_gauge_length() const;
  void clear_water_gauge_length();
  static const int kWaterGaugeLengthFieldNumber = 3;
  float water_gauge_length() const;
  void set_water_gauge_length(float value);

  // optional bool display = 4;
  bool has_display() const;
  void clear_display();
  static const int kDisplayFieldNumber = 4;
  bool display() const;
  void set_display(bool value);

  // @@protoc_insertion_point(class_scope:AlgorithmConfig)
 private:
  void set_has_algorithm_type();
  void clear_has_algorithm_type();
  void set_has_detect_interval();
  void clear_has_detect_interval();
  void set_has_water_gauge_length();
  void clear_has_water_gauge_length();
  void set_has_display();
  void clear_has_display();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AnalysisRect > roi_rects_;
  int algorithm_type_;
  ::google::protobuf::uint32 detect_interval_;
  float water_gauge_length_;
  bool display_;
  friend struct ::protobuf_AnalysisConfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AnalysisConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AnalysisConfig) */ {
 public:
  AnalysisConfig();
  virtual ~AnalysisConfig();

  AnalysisConfig(const AnalysisConfig& from);

  inline AnalysisConfig& operator=(const AnalysisConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalysisConfig(AnalysisConfig&& from) noexcept
    : AnalysisConfig() {
    *this = ::std::move(from);
  }

  inline AnalysisConfig& operator=(AnalysisConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalysisConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalysisConfig* internal_default_instance() {
    return reinterpret_cast<const AnalysisConfig*>(
               &_AnalysisConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AnalysisConfig* other);
  friend void swap(AnalysisConfig& a, AnalysisConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalysisConfig* New() const final {
    return CreateMaybeMessage<AnalysisConfig>(NULL);
  }

  AnalysisConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnalysisConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnalysisConfig& from);
  void MergeFrom(const AnalysisConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalysisConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AlgorithmConfig algorithms = 9;
  int algorithms_size() const;
  void clear_algorithms();
  static const int kAlgorithmsFieldNumber = 9;
  ::AlgorithmConfig* mutable_algorithms(int index);
  ::google::protobuf::RepeatedPtrField< ::AlgorithmConfig >*
      mutable_algorithms();
  const ::AlgorithmConfig& algorithms(int index) const;
  ::AlgorithmConfig* add_algorithms();
  const ::google::protobuf::RepeatedPtrField< ::AlgorithmConfig >&
      algorithms() const;

  // required string video_id = 1;
  bool has_video_id() const;
  void clear_video_id();
  static const int kVideoIdFieldNumber = 1;
  const ::std::string& video_id() const;
  void set_video_id(const ::std::string& value);
  #if LANG_CXX11
  void set_video_id(::std::string&& value);
  #endif
  void set_video_id(const char* value);
  void set_video_id(const char* value, size_t size);
  ::std::string* mutable_video_id();
  ::std::string* release_video_id();
  void set_allocated_video_id(::std::string* video_id);

  // required string input_url = 2;
  bool has_input_url() const;
  void clear_input_url();
  static const int kInputUrlFieldNumber = 2;
  const ::std::string& input_url() const;
  void set_input_url(const ::std::string& value);
  #if LANG_CXX11
  void set_input_url(::std::string&& value);
  #endif
  void set_input_url(const char* value);
  void set_input_url(const char* value, size_t size);
  ::std::string* mutable_input_url();
  ::std::string* release_input_url();
  void set_allocated_input_url(::std::string* input_url);

  // required string output_url = 3;
  bool has_output_url() const;
  void clear_output_url();
  static const int kOutputUrlFieldNumber = 3;
  const ::std::string& output_url() const;
  void set_output_url(const ::std::string& value);
  #if LANG_CXX11
  void set_output_url(::std::string&& value);
  #endif
  void set_output_url(const char* value);
  void set_output_url(const char* value, size_t size);
  ::std::string* mutable_output_url();
  ::std::string* release_output_url();
  void set_allocated_output_url(::std::string* output_url);

  // required string ttc_path = 4;
  bool has_ttc_path() const;
  void clear_ttc_path();
  static const int kTtcPathFieldNumber = 4;
  const ::std::string& ttc_path() const;
  void set_ttc_path(const ::std::string& value);
  #if LANG_CXX11
  void set_ttc_path(::std::string&& value);
  #endif
  void set_ttc_path(const char* value);
  void set_ttc_path(const char* value, size_t size);
  ::std::string* mutable_ttc_path();
  ::std::string* release_ttc_path();
  void set_allocated_ttc_path(::std::string* ttc_path);

  // required string send_url = 5;
  bool has_send_url() const;
  void clear_send_url();
  static const int kSendUrlFieldNumber = 5;
  const ::std::string& send_url() const;
  void set_send_url(const ::std::string& value);
  #if LANG_CXX11
  void set_send_url(::std::string&& value);
  #endif
  void set_send_url(const char* value);
  void set_send_url(const char* value, size_t size);
  ::std::string* mutable_send_url();
  ::std::string* release_send_url();
  void set_allocated_send_url(::std::string* send_url);

  // required uint32 detect_interval = 6;
  bool has_detect_interval() const;
  void clear_detect_interval();
  static const int kDetectIntervalFieldNumber = 6;
  ::google::protobuf::uint32 detect_interval() const;
  void set_detect_interval(::google::protobuf::uint32 value);

  // optional bool display = 7;
  bool has_display() const;
  void clear_display();
  static const int kDisplayFieldNumber = 7;
  bool display() const;
  void set_display(bool value);

  // optional bool open_modeling = 8;
  bool has_open_modeling() const;
  void clear_open_modeling();
  static const int kOpenModelingFieldNumber = 8;
  bool open_modeling() const;
  void set_open_modeling(bool value);

  // @@protoc_insertion_point(class_scope:AnalysisConfig)
 private:
  void set_has_video_id();
  void clear_has_video_id();
  void set_has_input_url();
  void clear_has_input_url();
  void set_has_output_url();
  void clear_has_output_url();
  void set_has_ttc_path();
  void clear_has_ttc_path();
  void set_has_send_url();
  void clear_has_send_url();
  void set_has_detect_interval();
  void clear_has_detect_interval();
  void set_has_display();
  void clear_has_display();
  void set_has_open_modeling();
  void clear_has_open_modeling();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AlgorithmConfig > algorithms_;
  ::google::protobuf::internal::ArenaStringPtr video_id_;
  ::google::protobuf::internal::ArenaStringPtr input_url_;
  ::google::protobuf::internal::ArenaStringPtr output_url_;
  ::google::protobuf::internal::ArenaStringPtr ttc_path_;
  ::google::protobuf::internal::ArenaStringPtr send_url_;
  ::google::protobuf::uint32 detect_interval_;
  bool display_;
  bool open_modeling_;
  friend struct ::protobuf_AnalysisConfig_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AnalysisAlarm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AnalysisAlarm) */ {
 public:
  AnalysisAlarm();
  virtual ~AnalysisAlarm();

  AnalysisAlarm(const AnalysisAlarm& from);

  inline AnalysisAlarm& operator=(const AnalysisAlarm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalysisAlarm(AnalysisAlarm&& from) noexcept
    : AnalysisAlarm() {
    *this = ::std::move(from);
  }

  inline AnalysisAlarm& operator=(AnalysisAlarm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalysisAlarm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalysisAlarm* internal_default_instance() {
    return reinterpret_cast<const AnalysisAlarm*>(
               &_AnalysisAlarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(AnalysisAlarm* other);
  friend void swap(AnalysisAlarm& a, AnalysisAlarm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalysisAlarm* New() const final {
    return CreateMaybeMessage<AnalysisAlarm>(NULL);
  }

  AnalysisAlarm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AnalysisAlarm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AnalysisAlarm& from);
  void MergeFrom(const AnalysisAlarm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnalysisAlarm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AnalysisRect rects = 7;
  int rects_size() const;
  void clear_rects();
  static const int kRectsFieldNumber = 7;
  ::AnalysisRect* mutable_rects(int index);
  ::google::protobuf::RepeatedPtrField< ::AnalysisRect >*
      mutable_rects();
  const ::AnalysisRect& rects(int index) const;
  ::AnalysisRect* add_rects();
  const ::google::protobuf::RepeatedPtrField< ::AnalysisRect >&
      rects() const;

  // optional string water_color = 3;
  bool has_water_color() const;
  void clear_water_color();
  static const int kWaterColorFieldNumber = 3;
  const ::std::string& water_color() const;
  void set_water_color(const ::std::string& value);
  #if LANG_CXX11
  void set_water_color(::std::string&& value);
  #endif
  void set_water_color(const char* value);
  void set_water_color(const char* value, size_t size);
  ::std::string* mutable_water_color();
  ::std::string* release_water_color();
  void set_allocated_water_color(::std::string* water_color);

  // required bool is_active = 1;
  bool has_is_active() const;
  void clear_is_active();
  static const int kIsActiveFieldNumber = 1;
  bool is_active() const;
  void set_is_active(bool value);

  // required .AlgorithmType scene_type = 2;
  bool has_scene_type() const;
  void clear_scene_type();
  static const int kSceneTypeFieldNumber = 2;
  ::AlgorithmType scene_type() const;
  void set_scene_type(::AlgorithmType value);

  // optional float floater_area = 4;
  bool has_floater_area() const;
  void clear_floater_area();
  static const int kFloaterAreaFieldNumber = 4;
  float floater_area() const;
  void set_floater_area(float value);

  // optional float floater_speed = 5;
  bool has_floater_speed() const;
  void clear_floater_speed();
  static const int kFloaterSpeedFieldNumber = 5;
  float floater_speed() const;
  void set_floater_speed(float value);

  // optional float water_gauge_num = 6;
  bool has_water_gauge_num() const;
  void clear_water_gauge_num();
  static const int kWaterGaugeNumFieldNumber = 6;
  float water_gauge_num() const;
  void set_water_gauge_num(float value);

  // @@protoc_insertion_point(class_scope:AnalysisAlarm)
 private:
  void set_has_is_active();
  void clear_has_is_active();
  void set_has_scene_type();
  void clear_has_scene_type();
  void set_has_water_color();
  void clear_has_water_color();
  void set_has_floater_area();
  void clear_has_floater_area();
  void set_has_floater_speed();
  void clear_has_floater_speed();
  void set_has_water_gauge_num();
  void clear_has_water_gauge_num();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AnalysisRect > rects_;
  ::google::protobuf::internal::ArenaStringPtr water_color_;
  bool is_active_;
  int scene_type_;
  float floater_area_;
  float floater_speed_;
  float water_gauge_num_;
  friend struct ::protobuf_AnalysisConfig_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConfigList

// required string model_path = 1;
inline bool ConfigList::has_model_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigList::set_has_model_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigList::clear_has_model_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigList::clear_model_path() {
  model_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_path();
}
inline const ::std::string& ConfigList::model_path() const {
  // @@protoc_insertion_point(field_get:ConfigList.model_path)
  return model_path_.GetNoArena();
}
inline void ConfigList::set_model_path(const ::std::string& value) {
  set_has_model_path();
  model_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ConfigList.model_path)
}
#if LANG_CXX11
inline void ConfigList::set_model_path(::std::string&& value) {
  set_has_model_path();
  model_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ConfigList.model_path)
}
#endif
inline void ConfigList::set_model_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_path();
  model_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ConfigList.model_path)
}
inline void ConfigList::set_model_path(const char* value, size_t size) {
  set_has_model_path();
  model_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ConfigList.model_path)
}
inline ::std::string* ConfigList::mutable_model_path() {
  set_has_model_path();
  // @@protoc_insertion_point(field_mutable:ConfigList.model_path)
  return model_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConfigList::release_model_path() {
  // @@protoc_insertion_point(field_release:ConfigList.model_path)
  if (!has_model_path()) {
    return NULL;
  }
  clear_has_model_path();
  return model_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfigList::set_allocated_model_path(::std::string* model_path) {
  if (model_path != NULL) {
    set_has_model_path();
  } else {
    clear_has_model_path();
  }
  model_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_path);
  // @@protoc_insertion_point(field_set_allocated:ConfigList.model_path)
}

// repeated string configs = 2;
inline int ConfigList::configs_size() const {
  return configs_.size();
}
inline void ConfigList::clear_configs() {
  configs_.Clear();
}
inline const ::std::string& ConfigList::configs(int index) const {
  // @@protoc_insertion_point(field_get:ConfigList.configs)
  return configs_.Get(index);
}
inline ::std::string* ConfigList::mutable_configs(int index) {
  // @@protoc_insertion_point(field_mutable:ConfigList.configs)
  return configs_.Mutable(index);
}
inline void ConfigList::set_configs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ConfigList.configs)
  configs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ConfigList::set_configs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ConfigList.configs)
  configs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ConfigList::set_configs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  configs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ConfigList.configs)
}
inline void ConfigList::set_configs(int index, const char* value, size_t size) {
  configs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ConfigList.configs)
}
inline ::std::string* ConfigList::add_configs() {
  // @@protoc_insertion_point(field_add_mutable:ConfigList.configs)
  return configs_.Add();
}
inline void ConfigList::add_configs(const ::std::string& value) {
  configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ConfigList.configs)
}
#if LANG_CXX11
inline void ConfigList::add_configs(::std::string&& value) {
  configs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ConfigList.configs)
}
#endif
inline void ConfigList::add_configs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  configs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ConfigList.configs)
}
inline void ConfigList::add_configs(const char* value, size_t size) {
  configs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ConfigList.configs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ConfigList::configs() const {
  // @@protoc_insertion_point(field_list:ConfigList.configs)
  return configs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ConfigList::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_list:ConfigList.configs)
  return &configs_;
}

// -------------------------------------------------------------------

// AnalysisRect

// required uint32 x = 1;
inline bool AnalysisRect::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalysisRect::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalysisRect::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalysisRect::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 AnalysisRect::x() const {
  // @@protoc_insertion_point(field_get:AnalysisRect.x)
  return x_;
}
inline void AnalysisRect::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:AnalysisRect.x)
}

// required uint32 y = 2;
inline bool AnalysisRect::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalysisRect::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalysisRect::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalysisRect::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 AnalysisRect::y() const {
  // @@protoc_insertion_point(field_get:AnalysisRect.y)
  return y_;
}
inline void AnalysisRect::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:AnalysisRect.y)
}

// required uint32 width = 3;
inline bool AnalysisRect::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnalysisRect::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnalysisRect::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnalysisRect::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 AnalysisRect::width() const {
  // @@protoc_insertion_point(field_get:AnalysisRect.width)
  return width_;
}
inline void AnalysisRect::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:AnalysisRect.width)
}

// required uint32 height = 4;
inline bool AnalysisRect::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnalysisRect::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnalysisRect::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnalysisRect::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 AnalysisRect::height() const {
  // @@protoc_insertion_point(field_get:AnalysisRect.height)
  return height_;
}
inline void AnalysisRect::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:AnalysisRect.height)
}

// -------------------------------------------------------------------

// AlgorithmConfig

// required .AlgorithmType algorithm_type = 1;
inline bool AlgorithmConfig::has_algorithm_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlgorithmConfig::set_has_algorithm_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlgorithmConfig::clear_has_algorithm_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlgorithmConfig::clear_algorithm_type() {
  algorithm_type_ = 0;
  clear_has_algorithm_type();
}
inline ::AlgorithmType AlgorithmConfig::algorithm_type() const {
  // @@protoc_insertion_point(field_get:AlgorithmConfig.algorithm_type)
  return static_cast< ::AlgorithmType >(algorithm_type_);
}
inline void AlgorithmConfig::set_algorithm_type(::AlgorithmType value) {
  assert(::AlgorithmType_IsValid(value));
  set_has_algorithm_type();
  algorithm_type_ = value;
  // @@protoc_insertion_point(field_set:AlgorithmConfig.algorithm_type)
}

// required uint32 detect_interval = 2;
inline bool AlgorithmConfig::has_detect_interval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlgorithmConfig::set_has_detect_interval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlgorithmConfig::clear_has_detect_interval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlgorithmConfig::clear_detect_interval() {
  detect_interval_ = 0u;
  clear_has_detect_interval();
}
inline ::google::protobuf::uint32 AlgorithmConfig::detect_interval() const {
  // @@protoc_insertion_point(field_get:AlgorithmConfig.detect_interval)
  return detect_interval_;
}
inline void AlgorithmConfig::set_detect_interval(::google::protobuf::uint32 value) {
  set_has_detect_interval();
  detect_interval_ = value;
  // @@protoc_insertion_point(field_set:AlgorithmConfig.detect_interval)
}

// optional float water_gauge_length = 3;
inline bool AlgorithmConfig::has_water_gauge_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AlgorithmConfig::set_has_water_gauge_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AlgorithmConfig::clear_has_water_gauge_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AlgorithmConfig::clear_water_gauge_length() {
  water_gauge_length_ = 0;
  clear_has_water_gauge_length();
}
inline float AlgorithmConfig::water_gauge_length() const {
  // @@protoc_insertion_point(field_get:AlgorithmConfig.water_gauge_length)
  return water_gauge_length_;
}
inline void AlgorithmConfig::set_water_gauge_length(float value) {
  set_has_water_gauge_length();
  water_gauge_length_ = value;
  // @@protoc_insertion_point(field_set:AlgorithmConfig.water_gauge_length)
}

// optional bool display = 4;
inline bool AlgorithmConfig::has_display() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AlgorithmConfig::set_has_display() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AlgorithmConfig::clear_has_display() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AlgorithmConfig::clear_display() {
  display_ = false;
  clear_has_display();
}
inline bool AlgorithmConfig::display() const {
  // @@protoc_insertion_point(field_get:AlgorithmConfig.display)
  return display_;
}
inline void AlgorithmConfig::set_display(bool value) {
  set_has_display();
  display_ = value;
  // @@protoc_insertion_point(field_set:AlgorithmConfig.display)
}

// repeated .AnalysisRect roi_rects = 5;
inline int AlgorithmConfig::roi_rects_size() const {
  return roi_rects_.size();
}
inline void AlgorithmConfig::clear_roi_rects() {
  roi_rects_.Clear();
}
inline ::AnalysisRect* AlgorithmConfig::mutable_roi_rects(int index) {
  // @@protoc_insertion_point(field_mutable:AlgorithmConfig.roi_rects)
  return roi_rects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::AnalysisRect >*
AlgorithmConfig::mutable_roi_rects() {
  // @@protoc_insertion_point(field_mutable_list:AlgorithmConfig.roi_rects)
  return &roi_rects_;
}
inline const ::AnalysisRect& AlgorithmConfig::roi_rects(int index) const {
  // @@protoc_insertion_point(field_get:AlgorithmConfig.roi_rects)
  return roi_rects_.Get(index);
}
inline ::AnalysisRect* AlgorithmConfig::add_roi_rects() {
  // @@protoc_insertion_point(field_add:AlgorithmConfig.roi_rects)
  return roi_rects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnalysisRect >&
AlgorithmConfig::roi_rects() const {
  // @@protoc_insertion_point(field_list:AlgorithmConfig.roi_rects)
  return roi_rects_;
}

// -------------------------------------------------------------------

// AnalysisConfig

// required string video_id = 1;
inline bool AnalysisConfig::has_video_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalysisConfig::set_has_video_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalysisConfig::clear_has_video_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalysisConfig::clear_video_id() {
  video_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_video_id();
}
inline const ::std::string& AnalysisConfig::video_id() const {
  // @@protoc_insertion_point(field_get:AnalysisConfig.video_id)
  return video_id_.GetNoArena();
}
inline void AnalysisConfig::set_video_id(const ::std::string& value) {
  set_has_video_id();
  video_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AnalysisConfig.video_id)
}
#if LANG_CXX11
inline void AnalysisConfig::set_video_id(::std::string&& value) {
  set_has_video_id();
  video_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AnalysisConfig.video_id)
}
#endif
inline void AnalysisConfig::set_video_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_video_id();
  video_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AnalysisConfig.video_id)
}
inline void AnalysisConfig::set_video_id(const char* value, size_t size) {
  set_has_video_id();
  video_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AnalysisConfig.video_id)
}
inline ::std::string* AnalysisConfig::mutable_video_id() {
  set_has_video_id();
  // @@protoc_insertion_point(field_mutable:AnalysisConfig.video_id)
  return video_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalysisConfig::release_video_id() {
  // @@protoc_insertion_point(field_release:AnalysisConfig.video_id)
  if (!has_video_id()) {
    return NULL;
  }
  clear_has_video_id();
  return video_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalysisConfig::set_allocated_video_id(::std::string* video_id) {
  if (video_id != NULL) {
    set_has_video_id();
  } else {
    clear_has_video_id();
  }
  video_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), video_id);
  // @@protoc_insertion_point(field_set_allocated:AnalysisConfig.video_id)
}

// required string input_url = 2;
inline bool AnalysisConfig::has_input_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalysisConfig::set_has_input_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalysisConfig::clear_has_input_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalysisConfig::clear_input_url() {
  input_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_input_url();
}
inline const ::std::string& AnalysisConfig::input_url() const {
  // @@protoc_insertion_point(field_get:AnalysisConfig.input_url)
  return input_url_.GetNoArena();
}
inline void AnalysisConfig::set_input_url(const ::std::string& value) {
  set_has_input_url();
  input_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AnalysisConfig.input_url)
}
#if LANG_CXX11
inline void AnalysisConfig::set_input_url(::std::string&& value) {
  set_has_input_url();
  input_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AnalysisConfig.input_url)
}
#endif
inline void AnalysisConfig::set_input_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_input_url();
  input_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AnalysisConfig.input_url)
}
inline void AnalysisConfig::set_input_url(const char* value, size_t size) {
  set_has_input_url();
  input_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AnalysisConfig.input_url)
}
inline ::std::string* AnalysisConfig::mutable_input_url() {
  set_has_input_url();
  // @@protoc_insertion_point(field_mutable:AnalysisConfig.input_url)
  return input_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalysisConfig::release_input_url() {
  // @@protoc_insertion_point(field_release:AnalysisConfig.input_url)
  if (!has_input_url()) {
    return NULL;
  }
  clear_has_input_url();
  return input_url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalysisConfig::set_allocated_input_url(::std::string* input_url) {
  if (input_url != NULL) {
    set_has_input_url();
  } else {
    clear_has_input_url();
  }
  input_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_url);
  // @@protoc_insertion_point(field_set_allocated:AnalysisConfig.input_url)
}

// required string output_url = 3;
inline bool AnalysisConfig::has_output_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnalysisConfig::set_has_output_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnalysisConfig::clear_has_output_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnalysisConfig::clear_output_url() {
  output_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_output_url();
}
inline const ::std::string& AnalysisConfig::output_url() const {
  // @@protoc_insertion_point(field_get:AnalysisConfig.output_url)
  return output_url_.GetNoArena();
}
inline void AnalysisConfig::set_output_url(const ::std::string& value) {
  set_has_output_url();
  output_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AnalysisConfig.output_url)
}
#if LANG_CXX11
inline void AnalysisConfig::set_output_url(::std::string&& value) {
  set_has_output_url();
  output_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AnalysisConfig.output_url)
}
#endif
inline void AnalysisConfig::set_output_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_output_url();
  output_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AnalysisConfig.output_url)
}
inline void AnalysisConfig::set_output_url(const char* value, size_t size) {
  set_has_output_url();
  output_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AnalysisConfig.output_url)
}
inline ::std::string* AnalysisConfig::mutable_output_url() {
  set_has_output_url();
  // @@protoc_insertion_point(field_mutable:AnalysisConfig.output_url)
  return output_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalysisConfig::release_output_url() {
  // @@protoc_insertion_point(field_release:AnalysisConfig.output_url)
  if (!has_output_url()) {
    return NULL;
  }
  clear_has_output_url();
  return output_url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalysisConfig::set_allocated_output_url(::std::string* output_url) {
  if (output_url != NULL) {
    set_has_output_url();
  } else {
    clear_has_output_url();
  }
  output_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_url);
  // @@protoc_insertion_point(field_set_allocated:AnalysisConfig.output_url)
}

// required string ttc_path = 4;
inline bool AnalysisConfig::has_ttc_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnalysisConfig::set_has_ttc_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnalysisConfig::clear_has_ttc_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnalysisConfig::clear_ttc_path() {
  ttc_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ttc_path();
}
inline const ::std::string& AnalysisConfig::ttc_path() const {
  // @@protoc_insertion_point(field_get:AnalysisConfig.ttc_path)
  return ttc_path_.GetNoArena();
}
inline void AnalysisConfig::set_ttc_path(const ::std::string& value) {
  set_has_ttc_path();
  ttc_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AnalysisConfig.ttc_path)
}
#if LANG_CXX11
inline void AnalysisConfig::set_ttc_path(::std::string&& value) {
  set_has_ttc_path();
  ttc_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AnalysisConfig.ttc_path)
}
#endif
inline void AnalysisConfig::set_ttc_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ttc_path();
  ttc_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AnalysisConfig.ttc_path)
}
inline void AnalysisConfig::set_ttc_path(const char* value, size_t size) {
  set_has_ttc_path();
  ttc_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AnalysisConfig.ttc_path)
}
inline ::std::string* AnalysisConfig::mutable_ttc_path() {
  set_has_ttc_path();
  // @@protoc_insertion_point(field_mutable:AnalysisConfig.ttc_path)
  return ttc_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalysisConfig::release_ttc_path() {
  // @@protoc_insertion_point(field_release:AnalysisConfig.ttc_path)
  if (!has_ttc_path()) {
    return NULL;
  }
  clear_has_ttc_path();
  return ttc_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalysisConfig::set_allocated_ttc_path(::std::string* ttc_path) {
  if (ttc_path != NULL) {
    set_has_ttc_path();
  } else {
    clear_has_ttc_path();
  }
  ttc_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ttc_path);
  // @@protoc_insertion_point(field_set_allocated:AnalysisConfig.ttc_path)
}

// required string send_url = 5;
inline bool AnalysisConfig::has_send_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnalysisConfig::set_has_send_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnalysisConfig::clear_has_send_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnalysisConfig::clear_send_url() {
  send_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_send_url();
}
inline const ::std::string& AnalysisConfig::send_url() const {
  // @@protoc_insertion_point(field_get:AnalysisConfig.send_url)
  return send_url_.GetNoArena();
}
inline void AnalysisConfig::set_send_url(const ::std::string& value) {
  set_has_send_url();
  send_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AnalysisConfig.send_url)
}
#if LANG_CXX11
inline void AnalysisConfig::set_send_url(::std::string&& value) {
  set_has_send_url();
  send_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AnalysisConfig.send_url)
}
#endif
inline void AnalysisConfig::set_send_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_send_url();
  send_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AnalysisConfig.send_url)
}
inline void AnalysisConfig::set_send_url(const char* value, size_t size) {
  set_has_send_url();
  send_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AnalysisConfig.send_url)
}
inline ::std::string* AnalysisConfig::mutable_send_url() {
  set_has_send_url();
  // @@protoc_insertion_point(field_mutable:AnalysisConfig.send_url)
  return send_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalysisConfig::release_send_url() {
  // @@protoc_insertion_point(field_release:AnalysisConfig.send_url)
  if (!has_send_url()) {
    return NULL;
  }
  clear_has_send_url();
  return send_url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalysisConfig::set_allocated_send_url(::std::string* send_url) {
  if (send_url != NULL) {
    set_has_send_url();
  } else {
    clear_has_send_url();
  }
  send_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), send_url);
  // @@protoc_insertion_point(field_set_allocated:AnalysisConfig.send_url)
}

// required uint32 detect_interval = 6;
inline bool AnalysisConfig::has_detect_interval() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnalysisConfig::set_has_detect_interval() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnalysisConfig::clear_has_detect_interval() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnalysisConfig::clear_detect_interval() {
  detect_interval_ = 0u;
  clear_has_detect_interval();
}
inline ::google::protobuf::uint32 AnalysisConfig::detect_interval() const {
  // @@protoc_insertion_point(field_get:AnalysisConfig.detect_interval)
  return detect_interval_;
}
inline void AnalysisConfig::set_detect_interval(::google::protobuf::uint32 value) {
  set_has_detect_interval();
  detect_interval_ = value;
  // @@protoc_insertion_point(field_set:AnalysisConfig.detect_interval)
}

// optional bool display = 7;
inline bool AnalysisConfig::has_display() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AnalysisConfig::set_has_display() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AnalysisConfig::clear_has_display() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AnalysisConfig::clear_display() {
  display_ = false;
  clear_has_display();
}
inline bool AnalysisConfig::display() const {
  // @@protoc_insertion_point(field_get:AnalysisConfig.display)
  return display_;
}
inline void AnalysisConfig::set_display(bool value) {
  set_has_display();
  display_ = value;
  // @@protoc_insertion_point(field_set:AnalysisConfig.display)
}

// optional bool open_modeling = 8;
inline bool AnalysisConfig::has_open_modeling() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AnalysisConfig::set_has_open_modeling() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AnalysisConfig::clear_has_open_modeling() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AnalysisConfig::clear_open_modeling() {
  open_modeling_ = false;
  clear_has_open_modeling();
}
inline bool AnalysisConfig::open_modeling() const {
  // @@protoc_insertion_point(field_get:AnalysisConfig.open_modeling)
  return open_modeling_;
}
inline void AnalysisConfig::set_open_modeling(bool value) {
  set_has_open_modeling();
  open_modeling_ = value;
  // @@protoc_insertion_point(field_set:AnalysisConfig.open_modeling)
}

// repeated .AlgorithmConfig algorithms = 9;
inline int AnalysisConfig::algorithms_size() const {
  return algorithms_.size();
}
inline void AnalysisConfig::clear_algorithms() {
  algorithms_.Clear();
}
inline ::AlgorithmConfig* AnalysisConfig::mutable_algorithms(int index) {
  // @@protoc_insertion_point(field_mutable:AnalysisConfig.algorithms)
  return algorithms_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::AlgorithmConfig >*
AnalysisConfig::mutable_algorithms() {
  // @@protoc_insertion_point(field_mutable_list:AnalysisConfig.algorithms)
  return &algorithms_;
}
inline const ::AlgorithmConfig& AnalysisConfig::algorithms(int index) const {
  // @@protoc_insertion_point(field_get:AnalysisConfig.algorithms)
  return algorithms_.Get(index);
}
inline ::AlgorithmConfig* AnalysisConfig::add_algorithms() {
  // @@protoc_insertion_point(field_add:AnalysisConfig.algorithms)
  return algorithms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AlgorithmConfig >&
AnalysisConfig::algorithms() const {
  // @@protoc_insertion_point(field_list:AnalysisConfig.algorithms)
  return algorithms_;
}

// -------------------------------------------------------------------

// AnalysisAlarm

// required bool is_active = 1;
inline bool AnalysisAlarm::has_is_active() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalysisAlarm::set_has_is_active() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalysisAlarm::clear_has_is_active() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalysisAlarm::clear_is_active() {
  is_active_ = false;
  clear_has_is_active();
}
inline bool AnalysisAlarm::is_active() const {
  // @@protoc_insertion_point(field_get:AnalysisAlarm.is_active)
  return is_active_;
}
inline void AnalysisAlarm::set_is_active(bool value) {
  set_has_is_active();
  is_active_ = value;
  // @@protoc_insertion_point(field_set:AnalysisAlarm.is_active)
}

// required .AlgorithmType scene_type = 2;
inline bool AnalysisAlarm::has_scene_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnalysisAlarm::set_has_scene_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnalysisAlarm::clear_has_scene_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnalysisAlarm::clear_scene_type() {
  scene_type_ = 0;
  clear_has_scene_type();
}
inline ::AlgorithmType AnalysisAlarm::scene_type() const {
  // @@protoc_insertion_point(field_get:AnalysisAlarm.scene_type)
  return static_cast< ::AlgorithmType >(scene_type_);
}
inline void AnalysisAlarm::set_scene_type(::AlgorithmType value) {
  assert(::AlgorithmType_IsValid(value));
  set_has_scene_type();
  scene_type_ = value;
  // @@protoc_insertion_point(field_set:AnalysisAlarm.scene_type)
}

// optional string water_color = 3;
inline bool AnalysisAlarm::has_water_color() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalysisAlarm::set_has_water_color() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalysisAlarm::clear_has_water_color() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalysisAlarm::clear_water_color() {
  water_color_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_water_color();
}
inline const ::std::string& AnalysisAlarm::water_color() const {
  // @@protoc_insertion_point(field_get:AnalysisAlarm.water_color)
  return water_color_.GetNoArena();
}
inline void AnalysisAlarm::set_water_color(const ::std::string& value) {
  set_has_water_color();
  water_color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AnalysisAlarm.water_color)
}
#if LANG_CXX11
inline void AnalysisAlarm::set_water_color(::std::string&& value) {
  set_has_water_color();
  water_color_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AnalysisAlarm.water_color)
}
#endif
inline void AnalysisAlarm::set_water_color(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_water_color();
  water_color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AnalysisAlarm.water_color)
}
inline void AnalysisAlarm::set_water_color(const char* value, size_t size) {
  set_has_water_color();
  water_color_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AnalysisAlarm.water_color)
}
inline ::std::string* AnalysisAlarm::mutable_water_color() {
  set_has_water_color();
  // @@protoc_insertion_point(field_mutable:AnalysisAlarm.water_color)
  return water_color_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AnalysisAlarm::release_water_color() {
  // @@protoc_insertion_point(field_release:AnalysisAlarm.water_color)
  if (!has_water_color()) {
    return NULL;
  }
  clear_has_water_color();
  return water_color_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AnalysisAlarm::set_allocated_water_color(::std::string* water_color) {
  if (water_color != NULL) {
    set_has_water_color();
  } else {
    clear_has_water_color();
  }
  water_color_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), water_color);
  // @@protoc_insertion_point(field_set_allocated:AnalysisAlarm.water_color)
}

// optional float floater_area = 4;
inline bool AnalysisAlarm::has_floater_area() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnalysisAlarm::set_has_floater_area() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnalysisAlarm::clear_has_floater_area() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnalysisAlarm::clear_floater_area() {
  floater_area_ = 0;
  clear_has_floater_area();
}
inline float AnalysisAlarm::floater_area() const {
  // @@protoc_insertion_point(field_get:AnalysisAlarm.floater_area)
  return floater_area_;
}
inline void AnalysisAlarm::set_floater_area(float value) {
  set_has_floater_area();
  floater_area_ = value;
  // @@protoc_insertion_point(field_set:AnalysisAlarm.floater_area)
}

// optional float floater_speed = 5;
inline bool AnalysisAlarm::has_floater_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnalysisAlarm::set_has_floater_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnalysisAlarm::clear_has_floater_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnalysisAlarm::clear_floater_speed() {
  floater_speed_ = 0;
  clear_has_floater_speed();
}
inline float AnalysisAlarm::floater_speed() const {
  // @@protoc_insertion_point(field_get:AnalysisAlarm.floater_speed)
  return floater_speed_;
}
inline void AnalysisAlarm::set_floater_speed(float value) {
  set_has_floater_speed();
  floater_speed_ = value;
  // @@protoc_insertion_point(field_set:AnalysisAlarm.floater_speed)
}

// optional float water_gauge_num = 6;
inline bool AnalysisAlarm::has_water_gauge_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnalysisAlarm::set_has_water_gauge_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnalysisAlarm::clear_has_water_gauge_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnalysisAlarm::clear_water_gauge_num() {
  water_gauge_num_ = 0;
  clear_has_water_gauge_num();
}
inline float AnalysisAlarm::water_gauge_num() const {
  // @@protoc_insertion_point(field_get:AnalysisAlarm.water_gauge_num)
  return water_gauge_num_;
}
inline void AnalysisAlarm::set_water_gauge_num(float value) {
  set_has_water_gauge_num();
  water_gauge_num_ = value;
  // @@protoc_insertion_point(field_set:AnalysisAlarm.water_gauge_num)
}

// repeated .AnalysisRect rects = 7;
inline int AnalysisAlarm::rects_size() const {
  return rects_.size();
}
inline void AnalysisAlarm::clear_rects() {
  rects_.Clear();
}
inline ::AnalysisRect* AnalysisAlarm::mutable_rects(int index) {
  // @@protoc_insertion_point(field_mutable:AnalysisAlarm.rects)
  return rects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::AnalysisRect >*
AnalysisAlarm::mutable_rects() {
  // @@protoc_insertion_point(field_mutable_list:AnalysisAlarm.rects)
  return &rects_;
}
inline const ::AnalysisRect& AnalysisAlarm::rects(int index) const {
  // @@protoc_insertion_point(field_get:AnalysisAlarm.rects)
  return rects_.Get(index);
}
inline ::AnalysisRect* AnalysisAlarm::add_rects() {
  // @@protoc_insertion_point(field_add:AnalysisAlarm.rects)
  return rects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AnalysisRect >&
AnalysisAlarm::rects() const {
  // @@protoc_insertion_point(field_list:AnalysisAlarm.rects)
  return rects_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::AlgorithmType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AlgorithmType>() {
  return ::AlgorithmType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_AnalysisConfig_2eproto
